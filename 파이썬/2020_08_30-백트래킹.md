## 백트래킹

> 해결책에 대한 후보를 구출해 나아가다 가능성이 없다고 판단되는 즉시 후보를 포기(철회; Backtrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제에 특히 유용하다.

- 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다는 데서 유래
- DFS - 백트래킹의 골격을 이루는 알고리즘
- 주로 재귀로 구현하며, 알고리즘마다 DFS 변형이 조금씩 일어나지만 기본적으로 모두 DFS의 범주에 속한다.
- 백트래킹은 가보고 되돌아오고를 반복한다. 운이 좋으면 시행착오를 덜 거치고, 운이 나쁘면 다 돌아야 하기 때문에 브루트 포스와 유사하다.
- 가다 포기하는 걸 트리의 가지치기(Pruning) 로 볼 수 있는데, 가지치기는 트리의 탐색 최적화 문제와도 관련이 깊다.



### 제약 충족 문제

Constraint Satisfaction Problems (CSP), 백트래킹은 제약 충족 문제를 풀이하는데 필수적인 알고리즘이다.

> 제약 충족 문제?
>
> 수많은 제약 조건(Constraints)을 충족하는 상태(State)를 찾아내는 수학 문제

- 제약 충족 문제의 대표격은 스도쿠 (1에서 9까지 숫자를 한 번만 넣은 제약이 존재)
- 스도쿠를 잘 풀이하려면 백트래킹을 하면서 가지치기를 통해 최적화하는 형태로 풀이할 수 있다.
- 그 외에도 십자말 풀이, 8퀸 문제, 4색 문제 등의 퍼즐 문제, 배낭 문제, 문자열 파싱, 조합 최적화 문제 등이 모두 제약 충족 문제에 속한다.



### 백트래킹 문제 -1 (섬의 갯수 구하기)

```
input : grid = [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","1","0","0","0"],
        ["0","0","0","0","0"]
    ]

output : 1
```

1인 부분은 육지.. 0은 바다.. 1의 덩어리를 찾으면 되는 문제.

```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        def dfs(i, j):
            
            if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or \
                grid[i][j] != '1':
                return
            
            # 이미 간 곳은 0으로 (back tracking)
            grid[i][j] = 0
            
            dfs(i-1, j)
            dfs(i+1, j)
            dfs(i, j+1)
            dfs(i, j-1)
            
        count = 0
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                
                if grid[i][j] == '1':
                    dfs(i,j)
                    count += 1
                    
        return count
```







